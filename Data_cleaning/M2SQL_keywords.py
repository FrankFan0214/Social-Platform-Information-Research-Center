# -*- coding: utf-8 -*-
"""專題-每日關鍵字2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18uC6due2Z2N_qE-xfsj6z3Ue3Ib9LI82

### ***Install & Import***
"""

!pip install pymongo                  # 安裝 pymongo，這是一個用來連線和操作 MongoDB 資料庫的 Python 庫
!pip install mysql-connector-python   # 安裝 mysql-connector-python，這是用來連線和操作 MySQL 資料庫的 Python 庫
!pip install jieba                    # 安裝 jieba，這是一個開源的中文斷詞工具，可用於中文文字處理
!pip install pandas                   # 安裝 pandas，一個強大的資料分析和處理工具，適合用於資料操作和資料框架處理

import os                                               # 匯入作業系統模組，用來進行與作業系統相關的操作
import pandas as pd                                     # 匯入 pandas，這是用於資料操作和分析的庫，特別是資料框架的處理
import pymongo                                          # 匯入 pymongo，用於連線和操作 MongoDB 資料庫
import mysql.connector                                  # 匯入 mysql.connector，用於連線和操作 MySQL 資料庫
import jieba                                            # 匯入 jieba，這是一個中文斷詞工具，可用於中文文字的處理
import re                                               # 匯入正規表示法模組，用於進行字串匹配和處理
import heapq                                            # 匯入 heapq，這個庫提供了堆操作相關的功能，主要用於優先佇列的實現
import logging                                          # 匯入 logging，用於記錄程式執行的日誌，方便除錯和監控
import sys
import itertools                                        # 新增這一行以匯入 itertools 模組
from pymongo import MongoClient                         # 從 pymongo 匯入 MongoClient，用於建立 MongoDB 的客戶端例項
from mysql.connector import Error, MySQLConnection, pooling # 從 mysql.connector 中匯入 Error，以便於處理資料庫的錯誤
from mysql.connector.cursor import MySQLCursor
from collections import defaultdict, Counter            # 從 collections 模組中匯入 defaultdict，一種字典的子類，能提供預設值
from datetime import datetime                           # 從 datetime 模組中匯入 datetime，提供日期和時間處理的功能
from contextlib import contextmanager                   # 匯入上下文管理器，用於資源管理
from functools import lru_cache                         # 匯入LRU快取，用於提升函式效能
from typing import Optional, List, Tuple, Dict, Any, Union    # 從 typing 模組中匯入指定的類型註釋

"""### ***Stopwords***


"""

CUSTOM_STOPWORDS = {
    "--", "2024", "com", "cc", "https", "表示", " ", "／", "X", "聆", "聽", "▪", ";", "★", "翻攝", "nothing", "imgur", "17","八卦","記者",
    "翻攝", "繼續", "Sent", "21", "20", "on", "my", "12", "16", "!","#","$","%","&","'","(",")","*","+",",","-","--",".","【", "】","\n",
    "..","...","/","0","1","2","3","4","5","6","7","8","9", "11", "17", "18", "19", "09", "15", "22","柴", "龜", "需要", "翻拍","一起", "一位",
    "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20","", "據傳","去年",
    "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40","話","吃","正在",
    "41", "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "60","註","news","天",
    "61", "62", "63", "64", "65", "66", "67", "68", "69", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "80","買","應該","我媽",
    "81", "82", "83", "84", "85", "86", "87", "88", "89", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "100","做","爸",
    ":",";","<","=",">",">>","?","@","A","[","]","^","_","`","|", "報導", "問題", "帳號", "這種", "是不是", "▲", "/", "內容", "", "請",
    "~","·","—","——","‘","’","“","”","…","、","。","〈","〉","《","》", "，", "」", "「", "說", "─", "後", "年", "月", "日", ".", "i", "￣",
    "一","一些","一何","一來","一切","一则","一則","一方面","一旦","一来", "使用者", "版主", "〔", "〕", "│", "Ｘ", "圖", "想","好像", "喜歡", "加利","買",
    "一样","一樣","一般","一转眼","七","万一","三","三天兩頭","三番五次", "-----", "三番兩次","上","上下","上來","上去","下","不","不下","過嗎","性",
    "不了","不亦樂乎", "不仅","不但","不但...而且","不僅","不僅...而且","不僅僅","不僅僅是", "不光","不免","不再","不力","不勝","不单","室","備",
    "不只","不可抗拒","不可開交", "不同","不問","不單","不外","不外乎","不大","不如","不妨","不定","不對", "不少","不尽","不尽然","不巧","應該","掛",
    "不已","不常","不得","不得不","不得了","不得已", "不必","不怎麼","不怕","不惟","不成","不拘","不擇手段","不料","不日","不是","方位", "發現","喔",
    "不時","不曾","不會","不止","不止一次","不比","不消","不滿","不然","不然的話", "不特","不独","不獨","不由得","不知不覺","不管","進行","註","手",
    "不管怎樣","不經意","不能","不能不", "不至于","不至於","不若","不要","不論","不论","不起","不过","不迭","不過","不问", "不限", "時間", "地區",
    "与","与其","与其说","与否","与此同时","且","且不说","且说","两者","並", "並且","並沒","並沒有","並無","並肩","並非","个","个别","錢","買","備",
    "串列","临","为","为了", "为什么","为何","为止","为此","为着","乃","乃至","乃至于","么","之","之一","之所以", "之类","之類","乌乎","做","吃","項",
    "乎","乒","乘","乘勝","乘勢","乘機","乘虛","乘隙","九","也", "也好","也罢","也罷","了","二","二来","二話不說","二話沒說","于","已經","一下","不可",
    "于是","于是乎", "云云","云尔","互","互相","五","些","交口","亦","人","人人","人们","人家","人民", "什么","什么样","什麼","什麼樣","隊","根本",
    "今","介于","仍","仍旧","仍然","仍舊","从","从此", "从而","他","他人","他们","他們","以","以上","以为","以便","以免","以及","以故","馬","н","е",
    "以期","以来","以至","以至于","以至於","以致","们","任","任何","任凭","任憑", "似的","但","但凡","但是","但願","何","何以","何况","天","轉載","一篇",
    "何嘗","何处","何妨","何必", "何时","何時","何樂而不為","何止","何況","何苦","何處","何須","余外","作为", "表示", "作為","你","你们","認識","準備",
    "你們","併排","使","使得","來","來不及","來得及","來看","來著", "來講","例如","依","依据","依照","便","便于","保管","保險","俺","話","樑","乙",
    "俺们","個","個人", "倍加","倍感","們","倒不如","倒不如說","倒是","倘","倘使","倘或","倘然","倘若","借", "假使","假如","假若","偏偏","根本","109",
    "偶爾","偶而","傥然","傳","傳聞","傳說","僅","僅僅","像", "儘可能","儘快","儘早","儘管","儘管如此","儘量","儿","充其極","充其量","充分","票","а",
    "先不先", "光","光是","內","全体","全力","全年","全然","全身心","全部","全都","兩者","八","八成", "公然","六","兮","共","共總","出現","發現","1500",
    "关于","其","其一","其中","其二","其他","其余","其它","其實", "其後","其次","其餘","具体地说","具体说来","具體來說","具體地說","處","高","樑","2758",
    "具體說來","兼之","内", "再","再其次","再则","再有","再者","再者说","再說","再说","冒","冲","况且","凝神","几", "几时","凡","凡是","地方","н","需",
    "凭","凭借","出","出于","出來","出去","出来","分别","分期","分期分批", "分頭","切","切不可","切切","切勿","切莫","则","则甚","初","感覺","完","B",
    "別","別人","別的","別說","别", "别人","别处","别是","别的","别管","别说","到","到了兒","到底","到目前為止","到處","到頭","一下","一天","麵","讀",
    "到頭來","則","前后","前後","前此","前者","剛","剛好","剛巧","剛才","加上","加之","加以", "勃然","動不動","動輒","匆匆","千","千萬","有點","笑",
    "千萬千萬","半","即","即令","即使","即便","即刻", "即如","即將","即或","即是說","即若","却","去","又","又及","及","及其","及至","反之","轉載","本板",
    "反之亦然","反之則","反倒","反倒是","反手","反而","反过来","反过来说","反過來","反過來說", "取道","受到","古來","另","另一個","欸","我爸","根本",
    "另一方面","另外","另悉","另方面","另行","只","只当", "只怕","只是","只有","只消","只要","只限","叫","叮咚","叮噹","可","可以","方面","人數","發言",
    "可好","可是", "可能","可見","可见","各","各个","各位","各個","各式","各种","各種","各自","同","同时", "同時","后","后者","向","龜","柴","女",
    "向使","向着","向著","吓","吗","否则","否則","吧","吧哒","吧噠", "吱","吶","呀","呃","呆呆地","呕","呗","呜","呜呼","呢","呵","需要","地區","不用",
    "呵呵","呸","呼哧","呼啦", "咋","和","咚","咦","咧","咱","咱们","咱們","咳","哇","哈","哈哈","哉","哎","哎呀", "哎哟","哎喲","哗","假","png","最新",
    "哟","哦","哩","哪","哪个","哪些","哪個","哪儿","哪兒","哪天","哪年", "哪怕","哪样","哪樣","哪裏","哪边","哪邊","哪里","哼","放","條","板","掛",
    "哼唷","唄","唉","唯有","啊","啊呀", "啊哈","啊喲","啐","啥","啦","啪达","啪達","啷当","喀","喂","喏","喔唷","單", "jpeg","欸","標題","張貼","方式",
    "單單","單純","喲","喽","嗎","嗚","嗚呼","嗡","嗡嗡","嗬","嗯","嗳","嘎","嘎嘎","嘎登", "嘔","嘘","嘛","嘩","嘩啦","嘻","嘿","A","十年","國","事",
    "嘿嘿","噓","噯","嚇","四","因","因为","因了", "表示" "因此","因為","因着","因而","固","固然","在","在下","在于","地","均","基于","假","png",
    "基於", "基本","基本上","处在","多","多么","多多","多多少少","多多益善","多少","多年來","多年前", "多次","多虧","夠瞧的","夥同","暫停","理由","期限",
    "大","大不了","大事","大凡","大多","大大","大家","大張旗鼓", "大抵","大概","大略","大約","大致","大舉","大都","大面兒上","大體","金","網址","tw",
    "大體上","奇","奈", "奮勇","她","她们","她們","好","好在","如","如上","如上所述","如下","如今","如何", "jpeg" "如其","如前所述","事","告訴","標題",
    "如同","如常","如是","如期","如果","如次","如此","如此等等","如若", "始而","姑且","存心","孰料","孰知","宁","宁可","宁愿","宁肯","tw","馬","鐘",
    "它","它们","它們", "jpg" "定","寧","寧可","寧肯","寧願","对","对于","对待","对方","对比","将","將","將才", "17", "將要","о","內文","連結","造",
    "將近","對","對於","小","尔","尔后","尔尔","尚且","就","就地","就是","就是了", "就是說","就是说","就此","就算","就要","尽","周四","拜","吹",
    "尽管","尽管如此","局外","居然","屆時", "屢","屢屢","屢次","屢次三番","岂但","川流不息","差一點","差不多","己","已", "jpg","о","死","殺","項"
    "已矣","巴","巴巴","帶","常","常常","常言說","常言說得好","常言道","平素","年覆一年","并","并且","并非","幾","幾乎","幾度","幾時","闆","這幾年",
    "幾番","幾經","庶乎","庶几","开外", "开始","弗","彈指之間","归","归齐","当","当地","当然","当着","彼","彼时","彼此","造成", "因此", "約","反正",
    "往","待","待到","很","很多","很少","後來","得","得了","得天獨厚","得起","從", "17", "從不","從中","從今以後","從來","從優","透露","и","當時",
    "從古到今","從古至今","從嚴","從寬","從小", "從新","從早到晚","從未","從此","從此以後","從無到有","從而","從輕","從速","從重","即日起","突然","最新",
    "從頭","徹夜","必","必定","必將","必須","快","快要","忽地","忽然","怎","怎么", "怎么办","怎么样","怎奈","怎样","怎樣","怎麼","珊","т","路上",
    "怎麼樣","怎麼辦","怕","急匆匆", "怪","怪不得","总之","总的来看","总的来说","总的说来","总而言之","恍然","恐怕", "恰似","恰好","週四","耍","廢",
    "恰如","恰巧","恰恰","恰恰相反","恰逢","您","惟其","慢說","慢说", "慣常","憑","憑藉","憤然","成年","成年累月","成心","我","已經","一年","死",
    "我们","我們","或", "知道", "或则","或多或少","或是","或曰","或者","或許","截然","截至","所","所以","所在", "所幸","所有","第一次","т","在網",
    "才","才能","打","打从","打從","打開天窗說亮話","把","抑或","抽冷子", "拿","按","按時","按期","按照","按理","按說","挨個","吼","東","a","e",
    "挨家挨戶","挨次","挨著", "挨門挨戶","挨門逐戶","换句话说","换言之","据","据此","接下來","接着","接著", "接連不斷","換句話說","遇到","死","殺",
    "換言之","撲通","據","據實","據悉","據我所知","據此","據稱", "據說","攔腰","放量","故","故意","故此","故而","敞開兒","敢","I","週五","忙",
    "敢情","敢於", "知道" "斷然","方","方才","方能","於","於是","於是乎","旁人","无","无宁","无论","既", "既...又","既往","a","e","宣布","創啦",
    "既是","既然","日漸","日益","日臻","日覆一日","日見","时候", "昂然","是","是以","是的","時候","暗中","暗地裏","暗自","更","難","級","創","每年",
    "更加","更為", "更進一步","曾","替","替代","最","會","有","有些","有关","有及","有时","有的", "有關","望","朝","朝着","朝著","周五","竹","潤",
    "末##末","本","本人","本地","本着","本著", "覺得", "本身","来","来着","来自","来说","极了","果然","果真","某","某个","某些","相信","下午","",
    "某個","某某","根据","根據","格外","梆","極","極了","極其","極力","極大", "極度","極為","極端","概","權時","次第","欤","新", "處","左右","原文",
    "正值","正如","正巧","正是", "此","此中","此地","此处","此外","此後","此时","此次","此間","此间","歷", "歸","歸根到底","柴", "龜","四五","點",
    "歸根結底","殆","毋宁","毋寧","每","每当","每時每刻","每每", "每當","每逢","比","比及","比如","比如說","比方","比照", "萬","蔣", "黃","違反",
    "比起","毫不","毫無", "毫無例外","毫無保留地","汝","決不","決非","沒","沒有","沖","沙沙","没奈何", "沿","沿着","沿著", "認為", "部分","署名",
    "況且","活","湊巧","滿","漫說","漫说","為","為了","為什麼", "為何","為著","烏乎","焉","無寧","無論","然","然则","然則","更多", "哲","要求",
    "然后","然後","然而", "照","照着","照著","爾後","爾等","牢牢","犹且","犹自","猛然","猛然間","獨", "獨自","率然","率爾","短", "係","站","連結",
    "理應","理當","理該","瑟瑟","甚且","甚么","甚或","甚而", "甚至","甚至于","甚麼","用","用来","甫","甭","由","由于","由於","度", "大型","Ａ",
    "由是","由此", "由此可見","由此可见","畢竟","略","略加","略微","略為","當","當下","當中", "覺得", "當兒","當即","當口兒", "王先生", "習","檢舉",
    "當場","當庭","當然","當真","當著","當頭","白","白白","的","的确","的確","的話","的话","皆可","盡","盡如人意","盡心盡力","複", "表檢視","規範",
    "盡心竭力","盡然","直到","相对而言","相對而言","省得","看","看上去","看來","看樣子","看起來","眨眼","着","着呢","矣","矣乎", " ","и","最新",
    "矣哉","砰","碰巧","社會主義","离","究竟","窮年累月", "竊","立","立刻","立地","立時","立馬","竟","竟然","竟而","第","等","等到","死","Ａ",
    "等等","策略地","简言之","管","簡直","簡而言之","簡言之","类如","粗","精光","純", "純粹","紧接着","累年","累次","結果","絕","絕不","希望",
    "絕對","絕非","絕頂","給","經", "經常","經過","綜上所述","緊接著","縱","縱令","縱使","縱然","縷縷","總之","總的來看", "☆", "","男","超過",
    "總的來說","總的說來","總而言之","繼之","繼而","纵","纵令","纵使","纵然","经","经过","结果", "给","继之","继后","继而","综上所述","李",
    "罢了","罷了","老","老大","老是","老老實實", "者","而","而且","而况","而又","而后","而外","而已","而後","而是","而況","而言","而論","包括",
    "聯袂","背地裏","背靠背","能","能否","腾","臨","臨到","自","自个儿","自从","自個兒", "自各儿","自各兒","自后","自家","自己","製", "一名",
    "自從","自打","自身","臭","至","至于", "至今","至於","至若","致","與","與其","與否","與此同時","舉凡","般的","若", "網友", "往下","找",
    "若夫","若是","若果","若非","莫","莫不","莫不然","莫如","莫若","莫非","萬一", "著","著呢","藉以","藉此","處處","虽","虽则","發生", "透過",
    "虽然","虽说","蠻","被","要","要不", "要不是","要不然","要么","要是","要麼","見","親口","親手","親眼","親自","親身", "；", "很大","併","處理",
    "設使","設若","話說","該","該當","誠然","誰","誰知","請勿","論","論說","諸位","謹", "譬喻","譬如","讓","让","许多","论", "民眾","攝","討論",
    "设使","设或","设若","诚如","诚然","该", "说来","诸","诸位","诸如","谁","谁人","谁料","谁知","豁然","豈","豈但","豈止", "風","活動","綜合",
    "豈非","贼死","赖以","赶","起","起來","起先","起初","起見","起见","起頭","起首", "趁","趁便","趁勢","趁早","趁機","趁熱", "歲","廣告","現場",
    "趁着","趁著","越是","趕","趕快", "趕早不趕晚","距","跟","路經","較","較之","較比","較為","轟然","较","较之","边", "卻", "也","活動","閱讀",
    "迄","过","近","近來","近年來","近幾年來","还","还是","还有","还要","这","这一来", "这个","这么","这么些","这么样","这么点儿","好奇","找",
    "这些","这会儿","这儿","这就是说", "这时","这样","这次","这般","这边","这里","进而","连","连同","迫於","逐步", "鄉", "對", "軍","一定","需要",
    "這","這些","這個","這兒","這就是說","這時","這會兒","這樣","這裏","這邊","這麼", "這麼些","這麼樣","這麼點兒","通过","通過", "公司","隻","時間",
    "逢","連","連同","連日","連日來", "連聲","連袂","連連","進來","進去","進而","過","過於","達旦","遲早","遵循","遵照", "明", "颱", "停止","需要",
    "還","還是","還有","邊","那","那个","那么","那么些","那么样","那些","那会儿","那個","那儿", "那兒","那时","那時","那會兒","規定","板主","地區",
    "那末","那样","那樣","那般","那裏","那边","那邊","那里", "那麼","那麼些","那麼樣","都","鄙人","鉴于","鑒於","针对","長期以來","長此下去","長線",
    "長話短說","開外","開始","間或","關於","阿","陡然","除","除了","除卻","除去","除外","除开", "除此","除此之外","除此以外","除此而外","最新",
    "除開","除非","陳年","随","随后","随时", "随着","隔夜","隔日","隨","隨著","难道说","雖","雖則","雖然","雖說","離","難得", "®", "強","龜",
    "難怪","難說","難道","雲雲","零","非但","非常","非徒","非得","非特","非独","完整", "10", "靠","頂多","頃","頃刻","頃刻之間","相關","龜",
    "頃刻間","順","順著","頓時","頗","顺", "表示", "顺着","風雨無阻","飽","餵","首先","馬上","騰","高低","麼","默然","默默地", "分","問卦",
    "齊","︿","！","＃","＄","％","＆","（","）","＊","＋", "直接", "，","０","１","２","３","４","５","６","７","８","９","：", "知道",
    "；","＜","＞","？","＠","［","］","｛","｜","｝","～", "直接", "10", "表示","￥","剛剛","之前","安安","某個","最近", "雙", "黨","柴",
    "這就","事情","原因","昨天","今天","明天", "這個","那個","如果","其實","即使","如題","大家","同時","以下","各位","真的","以前","板規",
    "以後","未來","是否","目前","要講","這兩個","前天","這樣","那樣","看起","一堆", "一個","有人","https","如題","媒體""來源", "；","人員",
    "台灣", "imgur", "www", "媒體", "違者", "看到", "com", "新聞", "來源", "文章", "以前", "刪除", "現在", "15", "一嘔", "","分類","柴",
    "表示", "知道", "jpg", "jpeg", "覺得", "from", "這次", "一直", "17", "長", "中", "時", "前", "元", "指出", "提供", "台", "臺", "復", "今年",
    "勿", "店", "使用", "請", "隨意", "走", "指定", "吋", "™", "王", "陳", "NT", "路", "神", "線", "影響", "路段", "運", "總", "推出"
}

"""### ***DatabaseManager***"""

class DatabaseManager:
    """資料庫管理類別，包括MongoDB和MySQL的配置與操作"""

    MONGO_URI = 'mongodb://xxx:xxxx@<IP>:28017/admin'  # MongoDB連線字串
    MYSQL_CONFIG = {  # MySQL配置字典
        'host': '<IP>',
        'database': 'PTT',
        'user': 'xxxx',
        'password': 'xxxx',
        'pool_size': 5,
        'pool_name': 'mypool',
        'buffered': True
    }
    BATCH_SIZE = 100  # 批次處理大小

    def __init__(self):
        """初始化方法，設定MongoDB客戶端和MySQL連線池"""
        self._mongo_client = None  # MongoDB客戶端
        self._mysql_pool = None  # MySQL連線池
        self._setup_logging()  # 設定日誌紀錄

    def _setup_logging(self):
        """配置日誌紀錄的處理器和格式"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('post_analyzer.log'),  # 寫入日誌檔案
                logging.StreamHandler()  # 也輸出到控制檯
            ]
        )

    @contextmanager
    def get_mongo_connection(self):
        """MongoDB連線的上下文管理器"""
        if not self._mongo_client:  # 檢查MongoDB客戶端是否已初始化
            try:
                self._mongo_client = MongoClient(DatabaseManager.MONGO_URI)  # 建立MongoDB連線
                db = self._mongo_client['kafka']  # 指定資料庫
                collection = db['merged_collection']  # 指定集合
                yield collection  # 輸出集合以供使用
            except Exception as e:
                logging.error(f"MongoDB連線錯誤: {e}")  # 紀錄錯誤資訊
                raise  # 引發例外
        else:
            yield self._mongo_client['kafka']['merged_collection']  # 使用已存在的MongoDB連線

    def _create_mysql_pool(self):
        """如果不存在，建立MySQL連線池"""
        if not self._mysql_pool:  # 檢查MySQL連線池是否已初始化
            try:
                self._mysql_pool = mysql.connector.pooling.MySQLConnectionPool(
                    **DatabaseManager.MYSQL_CONFIG  # 使用配置初始化連線池
                )
                logging.info("MySQL連線池建立成功")  # 紀錄成功訊息
            except Error as e:
                logging.error(f"建立MySQL連線池時出錯: {e}")  # 紀錄錯誤資訊
                raise  # 引發例外

    @contextmanager
    def get_mysql_connection(self):
        """MySQL連線的上下文管理器，使用連線池"""
        if not self._mysql_pool:  # 檢查是否需要建立MySQL連線池
            self._create_mysql_pool()  # 建立連線池

        connection = None  # 初始化連線變數
        try:
            connection = self._mysql_pool.get_connection()  # 從連線池獲取連線
            yield connection  # 輸出連線以供使用
        except Error as e:
            logging.error(f"從池中獲取MySQL連線時出錯: {e}")  # 紀錄錯誤資訊
            raise  # 引發例外
        finally:
            if connection:  # 確保連線被正確關閉
                connection.close()  # 關閉連線

"""### ***Data Cleaning & Transformation***"""

class KeywordStatisticsProcessor:
    """關鍵字統計處理器

    負責文章內容的關鍵字分析、統計和資料庫更新操作。

    主要功能：
    1. 文章關鍵字提取和計數
    2. 關鍵字統計結果轉換
    3. 資料庫更新操作
    """

    def __init__(self, stopwords=None, min_word_length=1, batch_size=100):
        """初始化處理器

        Args:
            stopwords: 停用詞集合
            min_word_length: 最小詞長度
            batch_size: 批次處理大小
        """
        self.stopwords = CUSTOM_STOPWORDS.union(set(stopwords or set()))
        self.min_word_length = max(1, min_word_length)
        self.batch_size = batch_size
        self.keyword_counts = defaultdict(lambda: defaultdict(lambda: defaultdict(int)))
        self._init_logger()

    def _init_logger(self):
        """初始化日誌系統"""
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(logging.INFO)

        # 檔案處理器（10MB，保留5個備份）
        file_handler = logging.handlers.RotatingFileHandler(
            'keyword_processor.log',
            maxBytes=10_000_000,
            backupCount=5
        )

        # 統一的日誌格式
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        file_handler.setFormatter(formatter)
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(formatter)

        self.logger.addHandler(file_handler)
        self.logger.addHandler(console_handler)

    def analyze_posts(self, contents):
        """分析文章內容，提取關鍵字並計數

        Args:
            contents: 單篇文章內容或文章列表

        Returns:
            List[Tuple[str, int]]: 關鍵字和出現次數的列表
        """
        if not contents:
            self.logger.warning("收到空內容")
            return []

        # 標準化輸入格式
        contents = [contents] if isinstance(contents, str) else contents

        # 使用Counter統計關鍵字
        keywords_counter = Counter()
        for content in contents:
            if isinstance(content, str) and content.strip():
                try:
                    words = [word for word in jieba.cut(content)
                            if self._is_valid_keyword(word)]
                    keywords_counter.update(words)
                except Exception as e:
                    self.logger.error(f"處理內容時發生錯誤: {str(e)}")

        return list(keywords_counter.items())

    def _is_valid_keyword(self, word):
        """檢查關鍵字是否有效

        Args:
            word: 待檢查的關鍵字

        Returns:
            bool: 是否為有效關鍵字
        """
        if not isinstance(word, str):
            return False

        # 去除空白字元
        word = word.strip()

        # 檢查基本條件
        if not word or word in self.stopwords:
            return False

        # 檢查長度
        if len(word) < self.min_word_length:
            return False

        # 檢查是否只包含特殊字元或空白
        if not any(c.isalnum() for c in word):
            return False

        # 檢查是否為單一特殊字元
        if len(word) == 1 and not word.isalnum():
            return False

        # 檢查是否為控制字元或無效Unicode
        if any(ord(c) < 32 or c == '\ufeff' or c == '\u200b' or c == '⁠' for c in word):
            return False

        return True

    def process_document(self, document, source=None):
        """處理單一文件的關鍵字統計

        Args:
            document: 文件資料
            source: 來源網站

        Returns:
            bool: 處理是否成功
        """
        try:
            # 提取必要資訊
            if not isinstance(document, dict):
                self.logger.error("文件格式錯誤: 需要字典類型")
                return False

            value = document.get('value', {})
            if not isinstance(value, dict):
                self.logger.error("文件value欄位格式錯誤: 需要字典類型")
                return False

            # 取得內容，優先使用'內容'欄位，否則使用'content'欄位
            content = value.get('內容') or value.get('content')
            if not content:
                self.logger.warning("文件缺少內容欄位")
                return False

            # 確定來源
            source = source or self._determine_source(str(document.get('key', '')))

            # 取得發布日期
            publish_date = self._get_document_date(document)
            if not publish_date:
                self.logger.warning(f"無法取得發布日期, 來源={source}")
                return False

            # 確保publish_date是字串類型
            publish_date = str(publish_date)

            # 統計關鍵字
            keyword_counts = self.analyze_posts(content)
            if not keyword_counts:
                self.logger.warning(f"未找到有效關鍵字, 來源={source}")
                return False

            # 更新統計資料
            for keyword, count in keyword_counts:
                if keyword and isinstance(count, (int, float)):
                    # 使用字串作為字典鍵值
                    self.keyword_counts[publish_date][source][keyword] += count

            return True

        except Exception as e:
            self.logger.error(f"處理文件時發生錯誤: {str(e)}")
            return False

#    @lru_cache(maxsize=1000)
    def _get_document_date(self, document):
        """從文件中提取日期

        Args:
            document: 文件資料

        Returns:
            str: 格式化的日期字串
        """
        try:
            if not isinstance(document, dict):
                return None

            value = document.get('value', {})
            if not isinstance(value, dict):
                return None

            date_fields = ['發佈日期', 'date', '發布時間', 'publish_date']

            # 依序檢查可能的日期欄位
            for field in date_fields:
                date_str = value.get(field)
                if date_str:
                    if formatted_date := self._format_date(str(date_str)):
                        return formatted_date

            # 如果找不到有效日期，使用當前日期
            return datetime.now().strftime('%Y-%m-%d')

        except Exception as e:
            self.logger.error(f"提取日期時發生錯誤: {str(e)}")
            return None

    def _format_date(self, date_string):
        """格式化日期字串為統一格式

        Args:
            date_string: 原始日期字串

        Returns:
            str: 格式化後的日期字串 (YYYY-MM-DD)
        """
        if not date_string:
            return None

        patterns = {
            r'(\d{4})-(\d{2})-(\d{2})': lambda m: f"{m.group(1)}-{m.group(2)}-{m.group(3)}",
            r'(\d{4})年(\d{1,2})月(\d{1,2})日': lambda m: f"{m.group(1)}-{int(m.group(2)):02d}-{int(m.group(3)):02d}",
            r'(\d{1,2})/(\d{1,2})': lambda m: f"{datetime.now().year}-{int(m.group(1)):02d}-{int(m.group(2)):02d}",
            r'(\d{4})-(\d{2})-(\d{2})T': lambda m: f"{m.group(1)}-{m.group(2)}-{m.group(3)}"
        }

        try:
            for pattern, formatter in patterns.items():
                if match := re.match(pattern, date_string):
                    return formatter(match)
            return None
        except Exception as e:
            self.logger.error(f"日期格式化錯誤: {e}, 原始字串: {date_string}")
            return None

    @staticmethod
    def _determine_source(url):
        """根據URL判斷來源網站

        Args:
            url: 網址字串

        Returns:
            str: 來源網站名稱
        """
        if not url:
            return 'ETtoday'

        source_mapping = {
            'ptt': 'PTT',
            'dcard': 'Dcard',
            'ettoday': 'ETtoday',
            'yahoo': 'Yahoo',
            'setn': '三立新聞網',
            'udn': '聯合新聞網',
            'ltn': '自由時報'
        }

        url_lower = url.lower()
        return next((value for key, value in source_mapping.items()
                    if key in url_lower), '其他新聞網')

    def get_top_keywords(self, date, source, n=15):
        """獲取特定日期和來源的熱門關鍵字

        Args:
            date: 日期
            source: 來源
            n: 返回的關鍵字數量

        Returns:
            Tuple[List, List]: 關鍵字列表和對應的次數列表
        """
        source_keywords = self.keyword_counts.get(date, {}).get(source, {})
        top_n = heapq.nlargest(n, source_keywords.items(), key=lambda x: x[1])

        keywords, counts = zip(*top_n) if top_n else ([], [])

        # 補足到指定長度
        keywords = list(keywords) + [None] * (n - len(keywords))
        counts = list(counts) + [None] * (n - len(counts))

        return keywords, counts

    def get_dataframe(self):
        """將關鍵字統計結果轉換為DataFrame

        Returns:
            pd.DataFrame: 包含關鍵字統計的DataFrame
        """
        data = []
        for date in sorted(self.keyword_counts):
            for source, keywords in self.keyword_counts[date].items():
                # 過濾掉無效的關鍵字
                valid_keywords = {k: v for k, v in keywords.items()
                               if k and self._is_valid_keyword(k)}

                # 如果該來源/日期組合沒有有效關鍵字，跳過
                if not valid_keywords:
                    continue

                # 取得前15個有效關鍵字
                top_keywords = heapq.nlargest(15, valid_keywords.items(),
                                            key=lambda x: x[1])

                for rank, (keyword, count) in enumerate(top_keywords, 1):
                    data.append({
                        "發佈日期": date,
                        "來源": source,
                        "排名": rank,
                        "關鍵字": keyword,
                        "次數": count
                    })

        return pd.DataFrame(data)

    def update_mysql_keywords(self, connection, cursor, df, table_name='每日關鍵詞'):
        """更新MySQL資料庫中的關鍵字統計

        Args:
            connection: MySQL連接
            cursor: MySQL游標
            df: 關鍵字統計DataFrame
            table_name: 資料表名稱

        Returns:
            bool: 更新是否成功
        """
        if not self._validate_dataframe(df):
            return False

        try:
            self._create_keyword_table(cursor, table_name)
            self._batch_update(connection, cursor, df, table_name)
            return True
        except Exception as e:
            self.logger.error(f"更新關鍵字失敗: {str(e)}")
            connection.rollback()
            return False

    def _validate_dataframe(self, df):
        """驗證DataFrame格式

        Args:
            df: 待驗證的DataFrame

        Returns:
            bool: 是否符合要求
        """
        required_columns = ['發佈日期', '來源', '排名', '關鍵字', '次數']
        return all(col in df.columns for col in required_columns)

    def _create_keyword_table(self, cursor, table_name):
        """創建或更新關鍵字資料表

        Args:
            cursor: MySQL游標
            table_name: 資料表名稱
        """
        drop_table_query = "DROP TABLE IF EXISTS {table_name}"
        create_table_query = f"""
        CREATE TABLE IF NOT EXISTS {table_name} (
            id INT AUTO_INCREMENT PRIMARY KEY,
            發佈日期 DATE NOT NULL,
            來源 VARCHAR(50) NOT NULL,
            排名 INT NOT NULL,
            關鍵字 VARCHAR(100) NOT NULL,  # 加入 NOT NULL 約束
            次數 INT NOT NULL,             # 加入 NOT NULL 約束
            更新時間 TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
            UNIQUE KEY 唯一關鍵字排名 (發佈日期, 來源, 排名),
            CHECK (關鍵字 != '' AND 關鍵字 IS NOT NULL)  # 加入 CHECK 約束
        ) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
        """
        cursor.execute(create_table_query)

    def _batch_update(self, connection, cursor, df, table_name):
        """批次更新關鍵字資料

        Args:
            connection: MySQL連接
            cursor: MySQL游標
            df: 關鍵字統計DataFrame
            table_name: 資料表名稱
        """
        update_query = f"""
        INSERT INTO {table_name} (發佈日期, 來源, 排名, 關鍵字, 次數)
        VALUES (%s, %s, %s, %s, %s)
        ON DUPLICATE KEY UPDATE
            關鍵字 = VALUES(關鍵字),
            次數 = VALUES(次數)
        """

        for i in range(0, len(df), self.batch_size):
            batch = df.iloc[i:i + self.batch_size]
            batch_data = [
                (row['發佈日期'], row['來源'], row['排名'],
                 row['關鍵字'], row['次數'])
                for _, row in batch.iterrows()
            ]
            cursor.executemany(update_query, batch_data)
            connection.commit()
            self.logger.info(f"已更新記錄 {i+1} 到 {min(i+self.batch_size, len(df))}")

"""### ***Main***"""

class MainProcessor:
    """主要數據處理器

    負責協調資料庫操作和關鍵字處理的完整工作流程。

    主要功能：
    1. 從MongoDB讀取文檔
    2. 處理文檔關鍵字
    3. 更新MySQL數據庫
    """

    def __init__(self, batch_size: int = 1000):
        """初始化處理器

        Args:
            batch_size: 批次處理大小
        """
        self.batch_size = batch_size
        self.db_manager = DatabaseManager()
        self.keyword_processor = KeywordStatisticsProcessor(
            stopwords=CUSTOM_STOPWORDS,
            batch_size=batch_size
        )
        self.logger = self._setup_logger()

    def _setup_logger(self) -> logging.Logger:
        """配置處理器專用的日誌記錄器

        Returns:
            logging.Logger: 配置好的日誌記錄器
        """
        logger = logging.getLogger(f"{__name__}.MainProcessor")
        logger.setLevel(logging.INFO)

        # 檔案處理器
        file_handler = logging.handlers.RotatingFileHandler(
            'main_processor.log',
            maxBytes=10_000_000,  # 10MB
            backupCount=5
        )

        # 日誌格式
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        file_handler.setFormatter(formatter)

        # 控制台處理器
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(formatter)

        logger.addHandler(file_handler)
        logger.addHandler(console_handler)

        return logger

    def process_data(self) -> bool:
        """執行完整的數據處理流程

        流程包括：
        1. 從MongoDB讀取文檔
        2. 批次處理文檔關鍵字
        3. 生成統計數據
        4. 更新MySQL數據庫

        Returns:
            bool: 處理是否成功
        """
        try:
            # 從MongoDB讀取並處理文檔
            documents = self._fetch_and_process_documents()
            if not documents:
                self.logger.warning("沒有找到需要處理的文檔")
                return False

            # 生成並更新關鍵字統計
            success = self._update_keyword_statistics()
            if success:
                self.logger.info("數據處理完成")
                return True
            else:
                self.logger.error("數據處理失敗")
                return False

        except Exception as e:
            self.logger.error(f"數據處理過程中發生錯誤: {str(e)}")
            raise

    def _fetch_and_process_documents(self) -> int:
        """從MongoDB讀取並處理文檔

        Returns:
            int: 處理的文檔數量
        """
        processed_count = 0

        with self.db_manager.get_mongo_connection() as collection:
            # 分批次處理文檔
            cursor = collection.find()
            while True:
                batch = list(itertools.islice(cursor, self.batch_size))
                if not batch:
                    break

                for doc in batch:
                    if self._process_single_document(doc):
                        processed_count += 1

                self.logger.info(f"已處理 {processed_count} 個文檔")

        return processed_count

    def _process_single_document(self, doc: Dict) -> bool:
        """處理單個文檔

        Args:
            doc: MongoDB文檔

        Returns:
            bool: 處理是否成功
        """
        try:
            key = doc.get('key', '')
            source = self.keyword_processor._determine_source(key)
            return self.keyword_processor.process_document(doc, source)

        except Exception as e:
            self.logger.error(f"處理文檔時發生錯誤: {str(e)}")
            return False

    def _update_keyword_statistics(self) -> bool:
        """更新關鍵字統計到MySQL

        Returns:
            bool: 更新是否成功
        """
        try:
            # 生成統計數據
            keywords_df = self.keyword_processor.get_dataframe()
            if keywords_df.empty:
                self.logger.warning("沒有關鍵字統計數據可更新")
                return False

            # 更新MySQL數據庫
            with self.db_manager.get_mysql_connection() as connection:
                cursor = connection.cursor()
                success = self.keyword_processor.update_mysql_keywords(
                    connection, cursor, keywords_df
                )
                cursor.close()
                return success

        except Exception as e:
            self.logger.error(f"更新關鍵字統計時發生錯誤: {str(e)}")
            return False


def main() -> int:
    """主程序入口

    初始化並執行數據處理流程，包含完整的錯誤處理和日誌記錄。

    Returns:
        int: 程序執行狀態碼
    """
    # 配置根日誌記錄器
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler('application.log'),
            logging.StreamHandler()
        ]
    )
    logger = logging.getLogger(__name__)

    try:
        # 設定執行環境
        logger.info("開始執行數據處理程序")

        # 初始化處理器
        processor = MainProcessor()

        # 執行處理流程
        if processor.process_data():
            logger.info("程序執行成功")
            return 0
        else:
            logger.error("程序執行失敗")
            return 1

    except KeyboardInterrupt:
        logger.info("程序被使用者中斷")
        return 2
    except Exception as e:
        logger.exception(f"程序執行時發生未預期的錯誤: {str(e)}")
        return 3
    finally:
        logger.info("程序結束執行")


if __name__ == "__main__":
    exit_code = main()  # 儲存回傳值而不是直接呼叫 sys.exit()