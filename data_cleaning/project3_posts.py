# -*- coding: utf-8 -*-
"""project3_各文章留言數與按讚數.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sbkGhS9PRnF8__3ZhLayT5lNAZX8GuIN

### ***Install & Import***
"""

!pip install pymongo
!pip install mysql-connector-python
!pip install jieba
!pip install pandas
!pip install nltk

import os
import pandas as pd
import pymongo
import mysql.connector
import jieba
import re
import heapq
import nltk
import json
import logging
from pymongo import MongoClient
from mysql.connector import Error
from collections import Counter, defaultdict
from datetime import datetime
from nltk.sentiment import SentimentIntensityAnalyzer
from typing import List, Dict, Any
from concurrent.futures import ThreadPoolExecutor
from functools import lru_cache

"""### ***Data Cleaning & Transformation***"""

# Commented out IPython magic to ensure Python compatibility.
class DatabaseManager:
    def __init__(self):
        # MongoDB 連接設定
        self.mongo_uri = "mongodb://XXXX:XXXX@<IP>:28017/admin"
        self.mongo_client = None
        self.mysql_conn = None
        self.mysql_cursor = None

# ---- ---- ---- ---- 建立連結至mongoDB ---- ---- ---- ---- ---- ---- ---- ----
    def connect_mongodb(self):
        try:
            self.mongo_client = MongoClient(self.mongo_uri)
            self.db = self.mongo_client['kafka']
            # 使用單一collection
            self.collection = self.db['Ptt']
            logging.info("Successfully connected to MongoDB")
        except Exception as e:
            logging.error(f"MongoDB connection error: {e}")
            raise
# ---- ---- ---- ---- 建立連結至MySQL ---- ---- ---- ---- ---- ---- ---- ----
    def connect_mysql(self):
        try:
            self.mysql_conn = mysql.connector.connect(
                host='<IP>',
                database='PTT',
                user='XXXX',
                password='XXXX',
                buffered=True,
                pool_size=5
            )
            self.mysql_cursor = self.mysql_conn.cursor()
            self.create_tables()
            logging.info("Successfully connected to MySQL")
        except Error as e:
            logging.error(f"MySQL connection error: {e}")
            raise
# ---- ---- ---- ---- 建立表格 ---- ---- ---- ---- ---- ---- ---- ----
    def create_tables(self):
        try:
            self.mysql_cursor.execute("""
                CREATE TABLE IF NOT EXISTS posts (
                    id VARCHAR(255) PRIMARY KEY,
                    來源 VARCHAR(50),
                    日期 DATE,
                    連結 VARCHAR(255),
                    主題 VARCHAR(100),
                    標題 TEXT,
                    內容 TEXT,
                    留言數 INT,
                    正向心情1 VARCHAR(50),
                    正向心情次數1 INT,
                    正向心情2 VARCHAR(50),
                    正向心情次數2 INT,
                    正向心情3 VARCHAR(50),
                    正向心情次數3 INT,
                    負向心情1 VARCHAR(50),
                    負向心情次數1 INT,
                    負向心情2 VARCHAR(50),
                    負向心情次數2 INT,
                    負向心情3 VARCHAR(50),
                    負向心情次數3 INT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    UNIQUE KEY unique_link (連結)
                ) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
            """)

            try:
                self.mysql_cursor.execute("CREATE INDEX idx_post_date ON posts(日期);")
                self.mysql_cursor.execute("CREATE INDEX idx_post_link ON posts(連結);")
            except Error as e:
                if e.errno != 1061:  # 1061 是索引已存在的錯誤碼
                    raise e

            self.mysql_conn.commit()
            logging.info("Tables and indexes created successfully")
        except Error as e:
            logging.error(f"Error creating tables: {e}")
            raise

class PostAnalyzer:
    def __init__(self):
        self.db_manager = DatabaseManager()
        self.db_manager.connect_mongodb()
        self.db_manager.connect_mysql()
        self.batch_size = 1000
        self.processed_links = {}  # 儲存已處理的連結和對應的最新日期
        self.load_processed_links()
# ---- ---- ---- ---- 處理文件 ---- ---- ---- ---- ---- ---- ---- ----
    def process_documents(self):
        """處理文件"""
        try:
            # 使用單一collection查詢
            documents = list(self.db_manager.collection.find({}))
            batch = []
            temp_posts = {}  # 暫存貼文，用於比較同一連結的不同版本

            for doc in documents:
                processed_data = self.process_single_document(doc)
                if not processed_data:
                    continue

                link = processed_data.get('link')
                date_str = processed_data.get('date')

                if not link or not date_str:
                    continue

                # Convert string date to datetime.date object for comparison
                try:
                    current_date = datetime.strptime(date_str, '%Y-%m-%d').date()
                except ValueError:
                    continue

                # 如果連結已存在於暫存中，比較日期並保留最新的
                if link in temp_posts:
                    temp_date = datetime.strptime(temp_posts[link]['date'], '%Y-%m-%d').date()
                    if current_date > temp_date:
                        temp_posts[link] = processed_data
                else:
                    temp_posts[link] = processed_data

                # 如果連結已在資料庫中且新的日期不是更新的，則跳過
                if link in self.processed_links:
                    stored_date = self.processed_links[link]
                    if isinstance(stored_date, str):
                        stored_date = datetime.strptime(stored_date, '%Y-%m-%d').date()
                    if current_date <= stored_date:
                        continue

            # 將暫存中的最新貼文加入批次
            batch.extend(temp_posts.values())

            if batch:
                self.save_batch(batch)

        except Exception as e:
            logging.error(f"Error processing documents: {e}")
            raise

    def load_processed_links(self):
        """載入已處理的文章連結和日期"""
        self.db_manager.mysql_cursor.execute("SELECT 連結, 日期 FROM posts")
        for link, date in self.db_manager.mysql_cursor.fetchall():
            if link:
                # Store the date as a string in 'YYYY-MM-DD' format
                self.processed_links[link] = date.strftime('%Y-%m-%d') if date else None
# ---- ---- ---- ---- 格式化日期 ---- ---- ---- ---- ---- ---- ---- ----
    @lru_cache(maxsize=1000)
    def format_date(self, date_string: str) -> str:
        """格式化日期，使用快取提高效能"""
        try:
            if not date_string:
                return None

            if "/" in date_string:
                date_obj = datetime.strptime(date_string, "%m/%d")
                return f"2024-{date_obj.month:02d}-{date_obj.day:02d}"
            elif "T" in date_string:
                date_obj = datetime.fromisoformat(date_string.replace('Z', '+00:00'))
                return f"2024-{date_obj.month:02d}-{date_obj.day:02d}"
            return None
        except Exception as e:
            logging.error(f"Date parsing error: {e}, date string: {date_string}")
            return None
# ---- ---- ---- ---- 處理資料 ---- ---- ---- ---- ---- ---- ---- ----
    def process_emotions(self, emotions_dict: Dict, is_positive: bool) -> List[tuple]:
        """處理情緒數據"""
        if is_positive:
            relevant_emotions = {'愛心': 0, '哈哈': 0, '跪': 0} if isinstance(emotions_dict, dict) else {'推': emotions_dict}
        else:
            relevant_emotions = {'驚訝': 0, '嗚嗚': 0, '森77': 0} if isinstance(emotions_dict, dict) else {'噓': emotions_dict}

        if isinstance(emotions_dict, dict):
            for emotion, count in emotions_dict.items():
                if emotion in relevant_emotions:
                    relevant_emotions[emotion] = int(count)

        return sorted(relevant_emotions.items(), key=lambda x: int(x[1]), reverse=True)[:3]
# ---- ---- ---- ---- 處理單一文件 ---- ---- ---- ---- ---- ---- ---- ----
    def process_single_document(self, doc: Dict) -> Dict:
        """處理單個文件"""
        try:
            post_id = str(doc['_id'])
            if 'value' not in doc:
                return None

            value = doc['value']
            if not isinstance(value, dict):
                return None

            source = 'PTT' if "ptt.cc" in doc.get('key', '') else 'Dcard' if "dcard.tw" in doc.get('key', '') else '其他'
            date = self.format_date(value.get('發布時間') or value.get('發佈日期'))
            link = value.get('連結')

            if not date or not link:
                return None

            title = value.get('標題', '')
            topic_match = re.search(r'\[(.*?)\]', title)
            topic = topic_match.group(1) if topic_match else '其他'
            clean_title = re.sub(r'\[.*?\]', '', title).strip()

            content = value.get('內容', '')
            comment_count = len(value.get('留言', [])) if value.get('留言') is not None else 0

            if source == 'Dcard':
                emoji_types = value.get('emoji類型', [{}])[0]
                positive_emotions = self.process_emotions(emoji_types, True)
                negative_emotions = self.process_emotions(emoji_types, False)
            else:
                positive_emotions = self.process_emotions(value.get('推', 0), True)
                negative_emotions = self.process_emotions(value.get('噓', 0), False)

            return {
                'id': post_id,
                'source': source,
                'date': date,
                'link': link,
                'topic': topic,
                'title': clean_title,
                'content': content,
                'comment_count': comment_count,
                'positive_emotions': positive_emotions,
                'negative_emotions': negative_emotions
            }

        except Exception as e:
            logging.error(f"Error processing document {post_id}: {e}")
            return None
# ---- ---- ---- ---- 批量保存 ---- ---- ---- ---- ---- ---- ---- ----
    def save_batch(self, batch: List[Dict]):
        """批量保存資料"""
        for post_data in batch:
            try:
                self.save_post(post_data)
                self.processed_links[post_data['link']] = post_data['date']
            except Exception as e:
                logging.error(f"Error saving batch data: {e}")
                continue
# ---- ---- ---- ---- 匯入MySQL ---- ---- ---- ---- ---- ---- ---- ----
    def save_post(self, post_data: Dict):
        """保存文章到MySQL"""
        try:
            insert_post_query = """
                INSERT INTO posts (
                    id, 來源, 日期, 連結, 主題, 標題, 內容, 留言數,
                    正向心情1, 正向心情次數1, 正向心情2, 正向心情次數2, 正向心情3, 正向心情次數3,
                    負向心情1, 負向心情次數1, 負向心情2, 負向心情次數2, 負向心情3, 負向心情次數3
                )
                VALUES (
#                     %s, %s, %s, %s, %s, %s, %s, %s,
#                     %s, %s, %s, %s, %s, %s,
#                     %s, %s, %s, %s, %s, %s
                )
                ON DUPLICATE KEY UPDATE
                來源 = VALUES(來源),
                日期 = VALUES(日期),
                主題 = VALUES(主題),
                標題 = VALUES(標題),
                內容 = VALUES(內容),
                留言數 = VALUES(留言數),
                正向心情1 = VALUES(正向心情1),
                正向心情次數1 = VALUES(正向心情次數1),
                正向心情2 = VALUES(正向心情2),
                正向心情次數2 = VALUES(正向心情次數2),
                正向心情3 = VALUES(正向心情3),
                正向心情次數3 = VALUES(正向心情次數3),
                負向心情1 = VALUES(負向心情1),
                負向心情次數1 = VALUES(負向心情次數1),
                負向心情2 = VALUES(負向心情2),
                負向心情次數2 = VALUES(負向心情次數2),
                負向心情3 = VALUES(負向心情3),
                負向心情次數3 = VALUES(負向心情次數3)
            """

            pos_emotions = list(post_data['positive_emotions'])
            pos_emotions.extend([('', 0)] * (3 - len(pos_emotions)))

            neg_emotions = list(post_data['negative_emotions'])
            neg_emotions.extend([('', 0)] * (3 - len(neg_emotions)))

            self.db_manager.mysql_cursor.execute(insert_post_query, (
                post_data['id'],
                post_data['source'],
                post_data['date'],
                post_data['link'],
                post_data['topic'],
                post_data['title'],
                post_data['content'],
                post_data['comment_count'],
                pos_emotions[0][0], pos_emotions[0][1],
                pos_emotions[1][0], pos_emotions[1][1],
                pos_emotions[2][0], pos_emotions[2][1],
                neg_emotions[0][0], neg_emotions[0][1],
                neg_emotions[1][0], neg_emotions[1][1],
                neg_emotions[2][0], neg_emotions[2][1]
            ))

            self.db_manager.mysql_conn.commit()

        except Error as e:
            logging.error(f"Error saving post: {e}")
            self.db_manager.mysql_conn.rollback()
            raise
# ---- ---- ---- ---- 關閉MySQL連線 ---- ---- ---- ---- ---- ---- ---- ----
    def close_connections(self):
        """關閉資料庫連接"""
        try:
            if self.db_manager.mysql_cursor:
                self.db_manager.mysql_cursor.close()
            if self.db_manager.mysql_conn:
                self.db_manager.mysql_conn.close()
            if self.db_manager.mongo_client:
                self.db_manager.mongo_client.close()
            logging.info("Database connections closed")
        except Exception as e:
            logging.error(f"Error closing connections: {e}")
# ---- ---- ---- ---- 執行主程式 ---- ---- ---- ---- ---- ---- ---- ----
def main():
    # 設定日誌
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        filename='post_analyzer.log'
    )

    analyzer = None
    try:
        analyzer = PostAnalyzer()
        analyzer.process_documents()
        logging.info("Processing completed successfully")
    except Exception as e:
        logging.error(f"Main process error: {e}")
    finally:
        if analyzer:
            analyzer.close_connections()

"""### ***Main***"""

if __name__ == "__main__":
    main()